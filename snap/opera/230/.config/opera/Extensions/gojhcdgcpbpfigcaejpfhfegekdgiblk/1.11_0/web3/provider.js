"use strict";const METAMASK_SPOOF_HOST_LIST=["adamantmine.com","app.allbridge.io","app.deversifi.com","app.gamee.com","app.hop.exchange","app.launchpool.xyz","app.openocean.finance","app.spiritswap.finance","app.xwg.games","beta.blockapescissors.com","boredapeyachtclub.com","bridge.roninchain.com","bridge.umbria.network","coinmarketcap.com","coinracer.io","crazydefenseheroes.com","cronosid.xyz","cryptocars.me","cryptoflowers.io","cryptopioneers.co","cryptounicorns.fun","curve.fi","dentedfeelsnft.com","etherlambos.io","foundation.app","game.lordless.io","gardenlockdown.com","guildfi.com","hashelot.onrender.com","hex.com","knownorigin.io","kyberswap.com","looksrare.org","market.immutable.com","marketplace.thetanarena.com","matcha.xyz","mcp3d.com","metalink.com","minted.network","nft.gamestop.com","niftychars.com","opensea.io","pegaxy.io","phantomgalaxies.com","play.mydefipet.com","pro.apeswap.finance","qorpo.world","stake.lido.fi","stargate.finance","thedustland.com","unstoppabledomains.com","wallet.polygon.technology","wolf.game","www.binance.com","www.cryptoatoms.org","www.cryptoblades.io","www.kingofeth.com","www.larvalabs.com","www.mintverse.com","www.mobox.io","www.nagemon.com","www.snailtrail.art","www.stateofthedapps.com","www.vibehub.io","www.voxels.com"];async function wallet_getPermissions(){const e=[];return this.selectedAddress&&e.push({caveats:[],invoker:window.location.origin,parentCapability:"eth_accounts"}),Promise.resolve(e)}async function wallet_requestPermissions(e){const n=[],t=e.params;this.selectedAddress&&n.push({caveats:[],invoker:window.location.origin,parentCapability:"eth_accounts"});const s=n.filter((e=>t.find((n=>e.parentCapability in n)))).map((e=>({date:Date.now(),parentCapability:e.parentCapability})));return Promise.resolve(s)}const ethMethodsRequestsMapping=new Map([["wallet_getPermissions",wallet_getPermissions],["wallet_requestPermissions",wallet_requestPermissions]]);(function(){class e{_events={};emit(e,...n){const t=this._events[e]||[];return t.forEach((e=>e.apply(this,n))),this}on(e,n){const t=this._events[e]||[];return this._events[e]=t.concat(n),this}addListener(e,n){return this.on(e,n)}off(e,n){const t=this._events[e];if(t){const s=t.lastIndexOf(n);if(s>=0){const n=t.filter(((e,n)=>n!==s));n.length?this._events[e]=n:delete this._events[e]}}return this}removeListener(e,n){return this.off(e,n)}removeAllListeners(e){return void 0===e?this._events={}:delete this._events[e],this}}function n(e){return`${(typeof e).charAt(0)}:${e}`}class t extends e{_port;_pending={};_id=0;connect(){const e=new MessageChannel;window.postMessage("InitializeOperaCryptoWalletWeb3Provider","*",[e.port2]);const n=e.port1;n.onmessage=e=>this._handleResponse(e.data),this._port=n}_nextId(){return 4294967295&++this._id}_handleResponse(e){if(a(e))return void this.emit(e.method,e.params);const t=n(e.id);if(!(t in this._pending))return;const s=this._pending[t];delete this._pending[t],s(e)}send(e){e.jsonrpc||(e.jsonrpc="2.0"),e.id=this._nextId();const t=n(e.id);if(t in this._pending)throw new Error(`Malformed request: RPC message with id ${e.id} pending`);return this._port||this.connect(),this._port.postMessage(e),new Promise((e=>this._pending[t]=e))}isConnected(){return!!this._port}}function s(e){let n;(function(e){e["Connect"]="elrond_connect",e["Disconnect"]="elrond_disconnect",e["SignMessage"]="elrond_signMessage",e["SignTransactions"]="elrond_signTransactions"})(n||(n={}));class t{value;constructor(e){this.value=e}bech32(){return this.value}}class s{value;constructor(e){this.value=e}hex(){return this.value}}class i{_initialized=!1;account={address:""};constructor(){if(window&&window.elrond)throw new Error("Error: Instantiation failed: Use getInstance method instead of new.")}disconnect(){return this.account.address="",this.startBgrMsgChannel(n.Disconnect)}ensureIsConnected(){if(!this.isConnected())throw new Error("Account is not connected")}ensureIsInitialized(){if(!this._initialized)throw new Error("OperaWallet provider is not initialized, call init() first")}async getAddress(){return this.ensureIsInitialized(),this.account?this.account.address:""}getInstance(){return this}async init(){return window&&window.elrond&&(this._initialized=!0),this._initialized}isConnected(){return e.isConnected()&&Boolean(this.account.address)}async login(e){this.ensureIsInitialized();const t=e||"";return await this.startBgrMsgChannel(n.Connect,t).then((e=>{this.setAddress(e)})).catch((e=>{console.error(e)})),this.account.address}async logout(){this.ensureIsInitialized();try{await this.disconnect()}catch(e){console.warn("OperaWallet provider origin url is already cleared!",e)}return!0}setAddress(e){return this.account.address=e,this}async signMessage(e){this.ensureIsConnected();const i={account:this.account.address,message:e.message.toString()},r=await this.startBgrMsgChannel(n.SignMessage,`Account: ${i.account}\nMessage: ${i.message}`);return e.applySignature(new s(r),new t(this.account.address)),e}async signTransaction(e){this.ensureIsConnected();const n=await this.signTransactions([e]);if(1!==n.length)throw new Error("Cannot sign single transaction.");return n[0]}async signTransactions(e){this.ensureIsConnected();const i=await this.startBgrMsgChannel(n.SignTransactions,{from:this.account.address,transactions:e.map((e=>e.toPlainObject()))});try{const n=new t(this.account.address);for(let t=0;t<e.length;t++){const r=e[t],o=i[t],a=new s(o.signature);r.applySignature(a,n)}return e}catch(r){throw new Error(`Transaction canceled: ${r.message}.`)}}startBgrMsgChannel(n,t){return new Promise(((s,i)=>{e.send({method:n,params:[t]}).then((e=>{o(e)?i(e.error):s(e.result)}))}))}}window.elrond=new i}function i(n){function t(e,n,t){Object.defineProperty(e,n,{enumerable:!0,value:t})}function s(e,n){return!!e.endsWith(n)&&(e.length===n.length||"."===e.at(-(n.length+1)))}function i(e){return!!METAMASK_SPOOF_HOST_LIST.find((n=>s(e,n)))}function a(e,n,t){const s=`Web3Provider.${t}`;if(e.length!==n.length)throw new TypeError(`${s} got ${e.length} arguments`);const i={o:"object",f:"function",s:"string"};for(let r=0;r<n.length;++r){const t=i[n.charAt(r)],o=typeof e[r];if(o!==t)throw new TypeError(`${s} argument ${r} got ${o}, expected ${t}`)}}function c(e,n){e.chainId=n||null,e.networkVersion=n?parseInt(n).toString():null}function d(e,n,t){const s=n.map((n=>e.send(Object.assign({},n)).then((e=>(e.id=n.id,e)))));Promise.allSettled(s).then((e=>{const n=e,s=n.map((e=>e.value));t(s.filter((e=>o(e))),s.filter((e=>!o(e))))}))}class h extends e{_rpc;selectedAddress=null;chainId=null;networkVersion=null;constructor(e){super(),this.enable=this.enable.bind(this),this.isConnected=this.isConnected.bind(this),this.send=this.send.bind(this),this.sendAsync=this.sendAsync.bind(this),this.request=this.request.bind(this),this._rpc=e,this._rpc.on("chainChanged",this._handleChainChange.bind(this)).on("accountsChanged",this._handleAccountsChange.bind(this)),!this._rpc.isConnected()&&this._rpc.connect()}enable(){a(arguments,"","enable()");let e=[];return this._rpc.send({method:"eth_requestAccounts"}).then((e=>o(e)?Promise.reject(e.error):Promise.resolve(e.result))).then((n=>(e=n,Promise.resolve(n)))).finally((()=>this._handleAccountsChange([e])))}isConnected(){return a(arguments,"","isConnected()"),this._rpc.isConnected()}send(e,n){if("string"===typeof e)return this.request({method:e,params:n});a(arguments,"o","send(request)");const{_rpc:t,networkVersion:s,selectedAddress:i}=this,r=new Map([["eth_accounts",()=>i&&[i]||[]],["eth_requestAccounts",()=>i&&[i]||[]],["eth_coinbase",()=>i||null],["eth_uninstallFilter",()=>(t.send(e),!0)],["net_version",()=>s||null]]),o=r.get(e.method)?.();if("undefined"===typeof o)throw new Error(`${e.method} not supported by synchronous send()`);return{id:e.id,jsonrpc:e.jsonrpc,result:o}}sendAsync(e,n){if(a(arguments,"of","sendAsync(request, callback)"),Array.isArray(e)){if(e.length>1)return void d(this._rpc,e,n);[e]=e}this._rpc.send(Object.assign({},e)).then((t=>{t.id=e.id,n(void 0,t)}))}request(e){a(arguments,"o","request(args)");const{method:n,params:t}=e;a([n],"s","request({method: string, ...})");const s={method:n,params:t||[]};if(ethMethodsRequestsMapping.has(s.method)){const e=ethMethodsRequestsMapping.get(s.method);return e.call(this,s)}return new Promise(((e,n)=>{this._rpc.send(s).then((t=>{o(t)?n(r(t)):e(t.result)}))}))}_handleChainChange(e){const[n]=e,{chainId:t}=this;c(this,n),t&&t!==this.chainId&&this.emit("chainChanged",this.chainId)}_handleAccountsChange(e){const[n=[]]=e,[t=null]=n,{selectedAddress:s}=this;this.selectedAddress=t,s&&s!==this.selectedAddress&&this.emit("accountsChanged",this.selectedAddress)}}function l(e,n){if(window.isOpera=!0,i(n))return t(e,"isMetaMask",!0),void t(e,"_metamask",{isUnlocked(){return Promise.resolve(!0)}});t(e,"isOpera",!0),t(e,"providerName","opera")}function u(e){const n="__isMetaMaskShim__";if(window.web3){const e=Object.keys(window.web3),t=1===e.length&&"currentProvider"===e[0],s=e.includes(n),i=t||s;if(!i)return}const s={currentProvider:e};t(s,n,!0),window.web3=s}const p=new h(n);l(p,location.host),u(p),window.ethereum=p}function r(e){if(e.error.response){const{error:n}=JSON.parse(e.error.response);return{code:n.code,message:n.message}}const{code:n,message:t}=e.error;return{code:n,message:t}}function o(e){return"error"in e}function a(e){return"undefined"===typeof e.id}function c(){const e=new t;i(e),s(e)}c()})();